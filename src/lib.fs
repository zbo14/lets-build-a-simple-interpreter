0 CONSTANT EOF
1 CONSTANT INT
2 CONSTANT ADD
3 CONSTANT SUB
4 CONSTANT MUL
5 CONSTANT DIV
6 CONSTANT LPAREN
7 CONSTANT RPAREN
8 CONSTANT _BEGIN
9 CONSTANT END
10 CONSTANT DOT
11 CONSTANT ASSIGN
12 CONSTANT SEMI
13 CONSTANT ID
14 CONSTANT NOOP

VARIABLE CHR
: CHR@ CHR C@ ;
: CHR! CHR C! ;
: CHR= CHR@ = ;
: CHR# CHR@ '0' - ;

0 VALUE LEN
: LEN+ LEN 1+ TO LEN ;
: LEN0 0 TO LEN ;

: STRING CREATE CHARS ALLOT DOES> CHARS + ;

32 STRING NAME
: NAME@ 0 NAME LEN ;
: NAME= NAME@ COMPARE 0= ;
: NAME+
    CHR@ LEN NAME C!
    LEN+ ;

: ERROR ( -- )
    ." Error parsing input" CR ABORT ;

: ISALPHA ( char -- bool )
    CHR@ 'A' 'Z' 1+ WITHIN
    CHR@ 'a' 'z' 1+ WITHIN OR ;

: ISDIGIT ( char -- bool )
    CHR@ '0' '9' 1+ WITHIN ;

: LOGSTACK CR .S ;

: ISWHITESPACE ( -- bool)
    9 CHR=
    13 CHR= OR
    32 CHR= OR ;

: ADVANCE ( -- )
    KEY DUP CHR! EMIT ;

: SKIPWHITESPACE ( -- )
    BEGIN
        ISWHITESPACE WHILE
        ADVANCE
    REPEAT ;

: GETINT
    0
    BEGIN
        ISDIGIT WHILE
        10 * CHR# +
        ADVANCE
    REPEAT
    INT ;

: GETNAME
    LEN0
    BEGIN
        ISALPHA WHILE
        NAME+ ADVANCE
    REPEAT
    s" BEGIN" NAME= IF _BEGIN ELSE
    s" END" NAME= IF END ELSE
    ID ENDIF ENDIF ;

DEFER _TOKEN

: GETCHAR
    CHR@ CASE
        9 OF SKIPWHITESPACE _TOKEN ENDOF
        13 OF CR SKIPWHITESPACE _TOKEN ENDOF
        32 OF SKIPWHITESPACE _TOKEN ENDOF
        '$' OF EOF ENDOF
        '+' OF ADVANCE ADD ENDOF
        '-' OF ADVANCE SUB ENDOF
        '*' OF ADVANCE MUL ENDOF
        '/' OF ADVANCE DIV ENDOF
        '(' OF ADVANCE LPAREN ENDOF
        ')' OF ADVANCE RPAREN ENDOF
        ';' OF ADVANCE SEMI ENDOF
        '.' OF ADVANCE DOT ENDOF
        ':' OF
            ADVANCE
            '=' CHR=
            IF ADVANCE ASSIGN
            ELSE ERROR
            ENDIF
        ENDOF
    ENDCASE ;

: TOKEN
    RECURSIVE
    ISALPHA IF GETNAME ELSE
    ISDIGIT IF GETINT ELSE
    GETCHAR ENDIF ENDIF ;

' TOKEN IS _TOKEN

: ISTERMOP
    DUP MUL = IF -1 ELSE DUP DIV = ENDIF ;

: BINOP
    RECURSIVE
    CASE
        EOF OF ENDOF
        INT OF ENDOF
        ADD OF BINOP >R BINOP R> + ENDOF
        SUB OF BINOP >R BINOP R> - ENDOF
        MUL OF BINOP >R BINOP R> * ENDOF
        DIV OF BINOP >R BINOP R> / ENDOF
    ENDCASE ;

DEFER _EXPR

: UNOP
    RECURSIVE
    CASE
        EOF OF ENDOF
        INT OF ENDOF
        ADD OF TOKEN UNOP ENDOF
        SUB OF TOKEN UNOP -1 * ENDOF
        LPAREN OF
            TOKEN _EXPR
            RPAREN =
            IF DROP
            ELSE ERROR
            ENDIF
        ENDOF
    ENDCASE ;

\ factor : (ADD|SUB)factor | INTEGER | LPAREN expr RPAREN | variable
: FACTOR
    CASE
        EOF OF EOF ENDOF
        ID OF ID ENDOF
        INT OF INT TOKEN ENDOF
        ADD OF ADD UNOP INT TOKEN ENDOF
        SUB OF SUB UNOP INT TOKEN ENDOF
        LPAREN OF
            TOKEN _EXPR
            RPAREN =
            IF TOKEN
            ELSE ERROR
            ENDIF
        ENDOF
    ENDCASE ;

: MULOP
    RECURSIVE
    CASE
        EOF OF MULOP EOF ENDOF
        END OF MULOP END ENDOF
        SEMI OF MULOP SEMI ENDOF
        INT OF INT MUL BINOP INT ENDOF
        MUL OF MUL BINOP INT MUL ENDOF
        DIV OF MUL BINOP INT DIV ENDOF
        ADD OF MUL BINOP INT ADD ENDOF
        SUB OF MUL BINOP INT SUB ENDOF
        RPAREN OF MULOP RPAREN ENDOF
    ENDCASE ;

: DIVOP
    RECURSIVE
    CASE
        EOF OF DIVOP EOF ENDOF
        END OF DIVOP END ENDOF
        SEMI OF DIVOP SEMI ENDOF
        INT OF INT DIV BINOP INT ENDOF
        MUL OF DIV BINOP INT MUL ENDOF
        DIV OF DIV BINOP INT DIV ENDOF
        ADD OF DIV BINOP INT ADD ENDOF
        SUB OF DIV BINOP INT SUB ENDOF
        RPAREN OF DIVOP RPAREN ENDOF
    ENDCASE ;

: TERMOP
    CASE
        MUL OF TOKEN FACTOR MULOP ENDOF
        DIV OF TOKEN FACTOR DIVOP ENDOF
    ENDCASE ;

\ term : factor ((MUL | DIV) factor)*
: TERM
    FACTOR
    BEGIN
        ISTERMOP WHILE
        TERMOP
    REPEAT ;

: ISEXPROP
    DUP ADD = IF -1 ELSE DUP SUB = ENDIF ;

: ADDOP
    RECURSIVE
    CASE
        EOF OF ADDOP EOF ENDOF
        END OF ADDOP END ENDOF
        SEMI OF ADDOP SEMI ENDOF
        INT OF INT ADD BINOP INT ENDOF
        ADD OF ADD BINOP INT ADD ENDOF
        SUB OF ADD BINOP INT SUB ENDOF
        RPAREN OF ADDOP RPAREN ENDOF
    ENDCASE ;

: SUBOP
    RECURSIVE
    CASE
        EOF OF SUBOP EOF ENDOF
        END OF SUBOP END ENDOF
        SEMI OF SUBOP SEMI ENDOF
        INT OF INT SUB BINOP INT ENDOF
        ADD OF SUB BINOP INT ADD ENDOF
        SUB OF SUB BINOP INT SUB ENDOF
        RPAREN OF SUBOP RPAREN ENDOF
    ENDCASE ;

: EXPROP
    CASE
        ADD OF TOKEN TERM ADDOP ENDOF
        SUB OF TOKEN TERM SUBOP ENDOF
    ENDCASE ;

\ expr : term ((ADD | SUB) term)*
: EXPR
    TERM
    BEGIN
        ISEXPROP WHILE
        EXPROP
    REPEAT ;

' EXPR IS _EXPR

: EAT = IF TOKEN ELSE ERROR ENDIF ;

: MATCH <> IF ERROR ENDIF ;

\ assignment : variable ASSIGN expr
: ASSIGNMENT
    ID EAT
    ASSIGN EAT
    EXPR
    CASE
        INT OF >R NAME@ NEXTNAME R> CONSTANT ENDOF
        ID OF NAME@
    ENDCASE

DEFER _COMPOUND

\ statement : compound | assignment | empty
: STATEMENT
    CASE
        _BEGIN OF _BEGIN _COMPOUND ENDOF
        ID OF ID ASSIGNMENT ENDOF
        \ NOOP OF NOOP ENDOF
        END OF END ENDOF
    ENDCASE ;

: PROCESS
    DUP SEMI =
    IF DROP TOKEN -1
    ELSE 0
    ENDIF ;

\ list : statement | statement SEMI list
: LIST
    STATEMENT
    BEGIN
        PROCESS WHILE
        STATEMENT
    REPEAT ;

\ compound : BEGIN list END .
: COMPOUND
    _BEGIN EAT
    LIST
    END MATCH ;

' COMPOUND IS _COMPOUND

: PROGRAM
    COMPOUND
    DOT MATCH ;

: RUN
    CR
    ADVANCE TOKEN
    COMPOUND ;
